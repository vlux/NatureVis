<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="Spiral (L-system)" />
    <title>L-system</title>
    <script src="d3/d3.js"></script>
    <style>
    .curve {
        fill: none;
        stroke: black;
        stroke-width: 1.5px;
    }
    .shadow {
        opacity: 0.1;
    }
    </style>
</head>
<body>
  <script>

  //compute a Lindenmayer system given an axiom, a number of steps and rules
  (function() {

      var curve, d, fractalize, height, svg, svg_path, transition, tweenDash,width;

      var piex = [],piey = [];

      fractalize = function(config) {
          var char, i, input, output, _i, _j, _len, _ref;
          input = config.axiom;
          for (i = _i = 0, _ref = config.steps; 0 <= _ref ? _i < _ref :_i > _ref; i = 0 <= _ref ? ++_i : --_i) {
              output = '';
              for (_j = 0, _len = input.length ; _j < _len; _j++) {
                  char = input[_j];
                  if (char in config.rules)
                      output += config.rules[char];
                  else
                      output += char;
              }
              input = output;
          }
          return output;
      };

      // convert a Lindenmayer string into an SVG path string
      svg_path = function(config) {
          var angle, char, path, _i, _len, _ref,idx;
          var xT,yT,nxT,nyT;
          var xcor= [],ycor = [],angles = [];
          idx = 1;
          angle = Math.PI / 2 * 3;
          path = 'M0 0';
          xT = 0,yT =0;
          _ref = config.fractal;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              char = _ref[_i];
              if (char === '+')
                  angle -= config.da;
              else if (char === '-')
                  angle += config.da;
              else if (char === 'F'){
                  nxT = xT + config.side * Math.cos(angle);
                  nyT = yT + config.side * Math.sin(angle);
                  path += "L" + nxT + " " + nyT;
                  xT = nxT;
                  yT = nyT;
              }
              else if (char === '['){
                  xcor[idx] = xT;
                  ycor[idx] = yT;
                  angles[idx++] = angle;
              }
              else if (char === ']'){
                  xT = xcor[--idx];
                  yT = ycor[idx ];
                  angle = angles[idx];
                  path += "M" + xT + " " + yT;
              }
              else if (char === 'E'){
                  piex.push(xT);
                  piey.push(yT);
              }
          }
          return path;
      };

      // animate the path
      // from Mike Bostock's stroke dash interpolation example http://bl.ocks.org/mbostock/5649592
      tweenDash = function() {
          var i, l;
          l = this.getTotalLength();
          i = d3.interpolateString('0,' + l, l + ',' + l);
          return function(t) {
              return i(t);
          };
      };
      transition = function(path) {
          return path.transition()
                .duration(20000)
                .attrTween('stroke-dasharray', tweenDash);
      };

      curve = fractalize({
          axiom:'FFFFFFFF[++FFFF[++FFFE]FFF[--FFFE]FFF[++FFFE]FFF[--FFFE]FFF[++FFFE]FFF[--FFFE]FFF[++FFFE]FFF[--FFFE]FFF[++FFFE]FFF[--FFFE]FFF[++FFFE]FFF[--FFFE]FFF]FFFFFFFF[--FFFF[--FFFE]FFF[++FFFE]FFF[--FFFE]FFF[++FFFE]FFF[--FFFE]FFF[++FFFE]FFF[--FFFE]FFF[++FFFE]FFF[--FFFE]FFF[++FFFE]FFF[--FFFE]FFF[++FFFE]FFF]FFFFFFFF[++FFFF[++FFFE]FFF[--FFFE]FFF[++FFFE]FFF[--FFFE]FFF[++FFFE]FFF[--FFFE]FFF[++FFFE]FFF[--FFFE]FFF[++FFFE]FFF[--FFFE]FFF[++FFFE]FFF[--FFFE]FFF]FFFFFFFF[--FFFF[--FFFE]FFF[++FFFE]FFF[--FFFE]FFF[++FFFE]FFF[--FFFE]FFF[++FFFE]FFF[--FFFE]FFF[++FFFE]FFF[--FFFE]FFF[++FFFE]FFF[--FFFE]FFF[++FFFE]FFF]FFFFFFFF[++FFFF[++FFFE]FFF[--FFFE]FFF[++FFFE]FFF[--FFFE]FFF[++FFFE]FFF[--FFFE]FFF[++FFFE]FFF[--FFFE]FFF[++FFFE]FFF[--FFFE]FFF[++FFFE]FFF[--FFFE]FFF]FFFFFFFF[--FFFF[--FFFE]FFF[++FFFE]FFF[--FFFE]FFF[++FFFE]FFF[--FFFE]FFF[++FFFE]FFF[--FFFE]FFF[++FFFE]FFF[--FFFE]FFF[++FFFE]FFF[--FFFE]FFF[++FFFE]FFF]FFFFFFFF[++FFFF[++FFFE]FFF[--FFFE]FFF[++FFFE]FFF[--FFFE]FFF[++FFFE]FFF[--FFFE]FFF[++FFFE]FFF[--FFFE]FFF[++FFFE]FFF[--FFFE]FFF[++FFFE]FFF[--FFFE]FFF]FFFFFFFF[--FFFF[--FFFE]FFF[++FFFE]FFF[--FFFE]FFF[++FFFE]FFF[--FFFE]FFF[++FFFE]FFF[--FFFE]FFF[++FFFE]FFF[--FFFE]FFF[++FFFE]FFF[--FFFE]FFF[++FFFE]FFF]FFFFFFFF[++FFFF[++FFFE]FFF[--FFFE]FFF[++FFFE]FFF[--FFFE]FFF[++FFFE]FFF[--FFFE]FFF[++FFFE]FFF[--FFFE]FFF[++FFFE]FFF[--FFFE]FFF[++FFFE]FFF[--FFFE]FFF]FFFFFFFF[--FFFF[--FFFE]FFF[++FFFE]FFF[--FFFE]FFF[++FFFE]FFF[--FFFE]FFF[++FFFE]FFF[--FFFE]FFF[++FFFE]FFF[--FFFE]FFF[++FFFE]FFF[--FFFE]FFF[++FFFE]FFF]FFFFFFFF',
          steps: 1,
          rules: {
          }
      });
      d = svg_path({
          fractal: curve,
          side: 6,      //length
          da:30 / 180 * Math.PI
      });

      width = 960;
      height = 760;

      console.log(piex);
      console.log(piey);

      svg = d3.select('body')
        	.append('svg')
            .attr('width', width)
            .attr('height', height);

      svg.append('path')
         .attr('class', 'curve shadow')
         .attr('d', d)
         .attr('transform', "translate(" + (width / 2) + "," + (height) +")");

      svg.append('path')
        .attr('class', 'curve')
        .attr('d', d)
        .attr('transform',"translate(" + (width / 2) + "," + (height) + ")")
        //.call(transition);

       svg.selectAll("circle")
          .data(piex)
          .enter()
          .append("circle")
          .attr("cx",function(d,i){
              return piex[i];
          })
          .attr("cy",function(d,i){
              return piey[i];
          })
          .attr("r",3)
          .attr('transform',"translate(" + (width / 2) + "," + (height) + ")")
          .style("fill","red");

  }).call(this);

</script>
</body>
</html>

<!-- matlab code -->
<!--
bemid = 'FFFFFFFF';
bran1 = 'FFF';
bran2 = 'FFF';
branc1 = [bran1 '[++' bran2 'E]' bran1 '[--' bran2 'E]'];
branc2 = [bran1 '[--' bran2 'E]' bran1 '[++' bran2 'E]'];
branch1 = ['F'];
branch2 = ['F'];
month = 12;
for i = 1: month / 2
    branch1 = [branch1 branc1];
    branch2 = [branch2 branc2];
end
branch1 = [branch1 bran2];
branch2 = [branch2 bran2];
axiom = [bemid '[++' branch1   ']' bemid '[--' branch2   ']' bemid '[++' branch1   ']' bemid '[--' branch2   ']'...
    bemid '[++' branch1   ']' bemid '[--' branch2   ']' bemid '[++' branch1   ']'...
    bemid '[--' branch2   ']' bemid '[++' branch1   ']' bemid '[--' branch2   ']' bemid]; -->
